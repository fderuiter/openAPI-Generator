# coding: utf-8

"""
    Mednet EDC API

    The Mednet EDC (Electronic Data Capture) REST API provides a single-point of access for reading data stored across iMednet data services. This specification documents all available endpoints in the latest version of the API. 

    The version of the OpenAPI document: 1.0.15
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.components_schemas_interval_forms_item import ComponentsSchemasIntervalFormsItem
from typing import Optional, Set
from typing_extensions import Self

class Interval(BaseModel):
    """
    Interval
    """ # noqa: E501
    study_key: Optional[StrictStr] = Field(default=None, description="Unique study key", alias="studyKey")
    interval_id: Optional[StrictInt] = Field(default=None, description="Unique system identifier for the interval (visit definition)", alias="intervalId")
    interval_name: Optional[StrictStr] = Field(default=None, description="Name of the interval (visit) as defined in the study", alias="intervalName")
    interval_description: Optional[StrictStr] = Field(default=None, description="Description of the interval (visit)", alias="intervalDescription")
    interval_sequence: Optional[StrictInt] = Field(default=None, description="Sequence number of the interval in the schedule", alias="intervalSequence")
    interval_group_id: Optional[StrictInt] = Field(default=None, description="Identifier for the interval group (if intervals are grouped)", alias="intervalGroupId")
    interval_group_name: Optional[StrictStr] = Field(default=None, description="Name of the interval group", alias="intervalGroupName")
    timeline: Optional[StrictStr] = Field(default=None, description="Type of interval visit window (e.g., None, Due Date, Start - End Date, Actual Date)")
    defined_using_interval: Optional[StrictStr] = Field(default=None, description="Baseline interval used for calculating this intervalâ€™s dates", alias="definedUsingInterval")
    window_calculation_form: Optional[StrictStr] = Field(default=None, description="Baseline form (name) from which the calculation date is taken", alias="windowCalculationForm")
    window_calculation_date: Optional[StrictStr] = Field(default=None, description="Baseline field (variable name) from which the calculation date is taken", alias="windowCalculationDate")
    actual_date_form: Optional[StrictStr] = Field(default=None, description="Form used to capture the actual date for this interval", alias="actualDateForm")
    actual_date: Optional[StrictStr] = Field(default=None, description="Field (variable name) used to capture the actual date for this interval", alias="actualDate")
    due_date_will_be_in: Optional[StrictInt] = Field(default=None, description="Number of days from the calculation date when the interval is due", alias="dueDateWillBeIn")
    negative_slack: Optional[StrictInt] = Field(default=None, description="Number of days before the due date that are allowed (negative window)", alias="negativeSlack")
    positive_slack: Optional[StrictInt] = Field(default=None, description="Number of days after the due date that are allowed (positive window)", alias="positiveSlack")
    epro_grace_period: Optional[StrictInt] = Field(default=None, description="Number of days of grace period for ePRO completion after due date", alias="eproGracePeriod")
    forms: Optional[List[ComponentsSchemasIntervalFormsItem]] = Field(default=None, description="List of forms that are scheduled in this interval")
    disabled: Optional[StrictBool] = Field(default=None, description="Whether the interval is soft-deleted (disabled)")
    date_created: Optional[StrictStr] = Field(default=None, description="Date when this interval was created", alias="dateCreated")
    date_modified: Optional[StrictStr] = Field(default=None, description="Date when this interval was last modified", alias="dateModified")
    __properties: ClassVar[List[str]] = ["studyKey", "intervalId", "intervalName", "intervalDescription", "intervalSequence", "intervalGroupId", "intervalGroupName", "timeline", "definedUsingInterval", "windowCalculationForm", "windowCalculationDate", "actualDateForm", "actualDate", "dueDateWillBeIn", "negativeSlack", "positiveSlack", "eproGracePeriod", "forms", "disabled", "dateCreated", "dateModified"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Interval from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in forms (list)
        _items = []
        if self.forms:
            for _item_forms in self.forms:
                if _item_forms:
                    _items.append(_item_forms.to_dict())
            _dict['forms'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Interval from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "studyKey": obj.get("studyKey"),
            "intervalId": obj.get("intervalId"),
            "intervalName": obj.get("intervalName"),
            "intervalDescription": obj.get("intervalDescription"),
            "intervalSequence": obj.get("intervalSequence"),
            "intervalGroupId": obj.get("intervalGroupId"),
            "intervalGroupName": obj.get("intervalGroupName"),
            "timeline": obj.get("timeline"),
            "definedUsingInterval": obj.get("definedUsingInterval"),
            "windowCalculationForm": obj.get("windowCalculationForm"),
            "windowCalculationDate": obj.get("windowCalculationDate"),
            "actualDateForm": obj.get("actualDateForm"),
            "actualDate": obj.get("actualDate"),
            "dueDateWillBeIn": obj.get("dueDateWillBeIn"),
            "negativeSlack": obj.get("negativeSlack"),
            "positiveSlack": obj.get("positiveSlack"),
            "eproGracePeriod": obj.get("eproGracePeriod"),
            "forms": [ComponentsSchemasIntervalFormsItem.from_dict(_item) for _item in obj["forms"]] if obj.get("forms") is not None else None,
            "disabled": obj.get("disabled"),
            "dateCreated": obj.get("dateCreated"),
            "dateModified": obj.get("dateModified")
        })
        return _obj


